// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.2
// source: message.proto

package message

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Message_ListSession_FullMethodName       = "/message.Message/ListSession"
	Message_SendMessage_FullMethodName       = "/message.Message/SendMessage"
	Message_AckMessage_FullMethodName        = "/message.Message/AckMessage"
	Message_DeleteUserSession_FullMethodName = "/message.Message/DeleteUserSession"
	Message_ListUnReadMessage_FullMethodName = "/message.Message/ListUnReadMessage"
	Message_CreateGroup_FullMethodName       = "/message.Message/CreateGroup"
	Message_ListGroup_FullMethodName         = "/message.Message/ListGroup"
	Message_DismissGroup_FullMethodName      = "/message.Message/DismissGroup"
	Message_InviteMember_FullMethodName      = "/message.Message/InviteMember"
	Message_MoveOutMember_FullMethodName     = "/message.Message/MoveOutMember"
	Message_ApplyInGroup_FullMethodName      = "/message.Message/ApplyInGroup"
	Message_HandleGroupApply_FullMethodName  = "/message.Message/HandleGroupApply"
	Message_ExitGroup_FullMethodName         = "/message.Message/ExitGroup"
	Message_UpdateGroupInfo_FullMethodName   = "/message.Message/UpdateGroupInfo"
	Message_ListGroupMember_FullMethodName   = "/message.Message/ListGroupMember"
	Message_SearchGroup_FullMethodName       = "/message.Message/SearchGroup"
	Message_ListGroupApply_FullMethodName    = "/message.Message/ListGroupApply"
	Message_CreateSession_FullMethodName     = "/message.Message/CreateSession"
)

// MessageClient is the client API for Message service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageClient interface {
	ListSession(ctx context.Context, in *ListSessionReq, opts ...grpc.CallOption) (*ListSessionResp, error)
	SendMessage(ctx context.Context, in *SendMessageReq, opts ...grpc.CallOption) (*SendMessageResp, error)
	AckMessage(ctx context.Context, in *AckMessageReq, opts ...grpc.CallOption) (*AckMessageResp, error)
	DeleteUserSession(ctx context.Context, in *DeleteUserSessionReq, opts ...grpc.CallOption) (*DeleteUserSessionResp, error)
	ListUnReadMessage(ctx context.Context, in *ListUnReadMessageReq, opts ...grpc.CallOption) (*ListUnReadMessageResp, error)
	CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*CreateGroupResq, error)
	ListGroup(ctx context.Context, in *ListGroupReq, opts ...grpc.CallOption) (*ListGroupResp, error)
	DismissGroup(ctx context.Context, in *DismissGroupReq, opts ...grpc.CallOption) (*DismissGroupResp, error)
	InviteMember(ctx context.Context, in *InviteMemberReq, opts ...grpc.CallOption) (*InviteMemberResp, error)
	MoveOutMember(ctx context.Context, in *MoveOutMemberReq, opts ...grpc.CallOption) (*MoveOutMemberResp, error)
	ApplyInGroup(ctx context.Context, in *ApplyInGroupReq, opts ...grpc.CallOption) (*ApplyInGroupResp, error)
	HandleGroupApply(ctx context.Context, in *HandleGroupApplyReq, opts ...grpc.CallOption) (*HandleGroupApplyResp, error)
	ExitGroup(ctx context.Context, in *ExitGroupReq, opts ...grpc.CallOption) (*ExitGroupResp, error)
	UpdateGroupInfo(ctx context.Context, in *UpdateGroupInfoReq, opts ...grpc.CallOption) (*UpdateGroupInfoResp, error)
	ListGroupMember(ctx context.Context, in *ListGroupMemberReq, opts ...grpc.CallOption) (*ListGroupMemberResp, error)
	SearchGroup(ctx context.Context, in *SearchGroupReq, opts ...grpc.CallOption) (*SearchGroupResp, error)
	ListGroupApply(ctx context.Context, in *ListGroupApplyReq, opts ...grpc.CallOption) (*ListGroupApplyResp, error)
	CreateSession(ctx context.Context, in *CreateSessionReq, opts ...grpc.CallOption) (*CreateSessionResp, error)
}

type messageClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageClient(cc grpc.ClientConnInterface) MessageClient {
	return &messageClient{cc}
}

func (c *messageClient) ListSession(ctx context.Context, in *ListSessionReq, opts ...grpc.CallOption) (*ListSessionResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSessionResp)
	err := c.cc.Invoke(ctx, Message_ListSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) SendMessage(ctx context.Context, in *SendMessageReq, opts ...grpc.CallOption) (*SendMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResp)
	err := c.cc.Invoke(ctx, Message_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) AckMessage(ctx context.Context, in *AckMessageReq, opts ...grpc.CallOption) (*AckMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckMessageResp)
	err := c.cc.Invoke(ctx, Message_AckMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) DeleteUserSession(ctx context.Context, in *DeleteUserSessionReq, opts ...grpc.CallOption) (*DeleteUserSessionResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserSessionResp)
	err := c.cc.Invoke(ctx, Message_DeleteUserSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ListUnReadMessage(ctx context.Context, in *ListUnReadMessageReq, opts ...grpc.CallOption) (*ListUnReadMessageResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUnReadMessageResp)
	err := c.cc.Invoke(ctx, Message_ListUnReadMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*CreateGroupResq, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResq)
	err := c.cc.Invoke(ctx, Message_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ListGroup(ctx context.Context, in *ListGroupReq, opts ...grpc.CallOption) (*ListGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupResp)
	err := c.cc.Invoke(ctx, Message_ListGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) DismissGroup(ctx context.Context, in *DismissGroupReq, opts ...grpc.CallOption) (*DismissGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DismissGroupResp)
	err := c.cc.Invoke(ctx, Message_DismissGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) InviteMember(ctx context.Context, in *InviteMemberReq, opts ...grpc.CallOption) (*InviteMemberResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InviteMemberResp)
	err := c.cc.Invoke(ctx, Message_InviteMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) MoveOutMember(ctx context.Context, in *MoveOutMemberReq, opts ...grpc.CallOption) (*MoveOutMemberResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveOutMemberResp)
	err := c.cc.Invoke(ctx, Message_MoveOutMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ApplyInGroup(ctx context.Context, in *ApplyInGroupReq, opts ...grpc.CallOption) (*ApplyInGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyInGroupResp)
	err := c.cc.Invoke(ctx, Message_ApplyInGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) HandleGroupApply(ctx context.Context, in *HandleGroupApplyReq, opts ...grpc.CallOption) (*HandleGroupApplyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandleGroupApplyResp)
	err := c.cc.Invoke(ctx, Message_HandleGroupApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ExitGroup(ctx context.Context, in *ExitGroupReq, opts ...grpc.CallOption) (*ExitGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExitGroupResp)
	err := c.cc.Invoke(ctx, Message_ExitGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) UpdateGroupInfo(ctx context.Context, in *UpdateGroupInfoReq, opts ...grpc.CallOption) (*UpdateGroupInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGroupInfoResp)
	err := c.cc.Invoke(ctx, Message_UpdateGroupInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ListGroupMember(ctx context.Context, in *ListGroupMemberReq, opts ...grpc.CallOption) (*ListGroupMemberResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupMemberResp)
	err := c.cc.Invoke(ctx, Message_ListGroupMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) SearchGroup(ctx context.Context, in *SearchGroupReq, opts ...grpc.CallOption) (*SearchGroupResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchGroupResp)
	err := c.cc.Invoke(ctx, Message_SearchGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) ListGroupApply(ctx context.Context, in *ListGroupApplyReq, opts ...grpc.CallOption) (*ListGroupApplyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupApplyResp)
	err := c.cc.Invoke(ctx, Message_ListGroupApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageClient) CreateSession(ctx context.Context, in *CreateSessionReq, opts ...grpc.CallOption) (*CreateSessionResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSessionResp)
	err := c.cc.Invoke(ctx, Message_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServer is the server API for Message service.
// All implementations must embed UnimplementedMessageServer
// for forward compatibility.
type MessageServer interface {
	ListSession(context.Context, *ListSessionReq) (*ListSessionResp, error)
	SendMessage(context.Context, *SendMessageReq) (*SendMessageResp, error)
	AckMessage(context.Context, *AckMessageReq) (*AckMessageResp, error)
	DeleteUserSession(context.Context, *DeleteUserSessionReq) (*DeleteUserSessionResp, error)
	ListUnReadMessage(context.Context, *ListUnReadMessageReq) (*ListUnReadMessageResp, error)
	CreateGroup(context.Context, *CreateGroupReq) (*CreateGroupResq, error)
	ListGroup(context.Context, *ListGroupReq) (*ListGroupResp, error)
	DismissGroup(context.Context, *DismissGroupReq) (*DismissGroupResp, error)
	InviteMember(context.Context, *InviteMemberReq) (*InviteMemberResp, error)
	MoveOutMember(context.Context, *MoveOutMemberReq) (*MoveOutMemberResp, error)
	ApplyInGroup(context.Context, *ApplyInGroupReq) (*ApplyInGroupResp, error)
	HandleGroupApply(context.Context, *HandleGroupApplyReq) (*HandleGroupApplyResp, error)
	ExitGroup(context.Context, *ExitGroupReq) (*ExitGroupResp, error)
	UpdateGroupInfo(context.Context, *UpdateGroupInfoReq) (*UpdateGroupInfoResp, error)
	ListGroupMember(context.Context, *ListGroupMemberReq) (*ListGroupMemberResp, error)
	SearchGroup(context.Context, *SearchGroupReq) (*SearchGroupResp, error)
	ListGroupApply(context.Context, *ListGroupApplyReq) (*ListGroupApplyResp, error)
	CreateSession(context.Context, *CreateSessionReq) (*CreateSessionResp, error)
	mustEmbedUnimplementedMessageServer()
}

// UnimplementedMessageServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServer struct{}

func (UnimplementedMessageServer) ListSession(context.Context, *ListSessionReq) (*ListSessionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSession not implemented")
}
func (UnimplementedMessageServer) SendMessage(context.Context, *SendMessageReq) (*SendMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedMessageServer) AckMessage(context.Context, *AckMessageReq) (*AckMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckMessage not implemented")
}
func (UnimplementedMessageServer) DeleteUserSession(context.Context, *DeleteUserSessionReq) (*DeleteUserSessionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserSession not implemented")
}
func (UnimplementedMessageServer) ListUnReadMessage(context.Context, *ListUnReadMessageReq) (*ListUnReadMessageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUnReadMessage not implemented")
}
func (UnimplementedMessageServer) CreateGroup(context.Context, *CreateGroupReq) (*CreateGroupResq, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedMessageServer) ListGroup(context.Context, *ListGroupReq) (*ListGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroup not implemented")
}
func (UnimplementedMessageServer) DismissGroup(context.Context, *DismissGroupReq) (*DismissGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DismissGroup not implemented")
}
func (UnimplementedMessageServer) InviteMember(context.Context, *InviteMemberReq) (*InviteMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteMember not implemented")
}
func (UnimplementedMessageServer) MoveOutMember(context.Context, *MoveOutMemberReq) (*MoveOutMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveOutMember not implemented")
}
func (UnimplementedMessageServer) ApplyInGroup(context.Context, *ApplyInGroupReq) (*ApplyInGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyInGroup not implemented")
}
func (UnimplementedMessageServer) HandleGroupApply(context.Context, *HandleGroupApplyReq) (*HandleGroupApplyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleGroupApply not implemented")
}
func (UnimplementedMessageServer) ExitGroup(context.Context, *ExitGroupReq) (*ExitGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExitGroup not implemented")
}
func (UnimplementedMessageServer) UpdateGroupInfo(context.Context, *UpdateGroupInfoReq) (*UpdateGroupInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroupInfo not implemented")
}
func (UnimplementedMessageServer) ListGroupMember(context.Context, *ListGroupMemberReq) (*ListGroupMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupMember not implemented")
}
func (UnimplementedMessageServer) SearchGroup(context.Context, *SearchGroupReq) (*SearchGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchGroup not implemented")
}
func (UnimplementedMessageServer) ListGroupApply(context.Context, *ListGroupApplyReq) (*ListGroupApplyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupApply not implemented")
}
func (UnimplementedMessageServer) CreateSession(context.Context, *CreateSessionReq) (*CreateSessionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedMessageServer) mustEmbedUnimplementedMessageServer() {}
func (UnimplementedMessageServer) testEmbeddedByValue()                 {}

// UnsafeMessageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServer will
// result in compilation errors.
type UnsafeMessageServer interface {
	mustEmbedUnimplementedMessageServer()
}

func RegisterMessageServer(s grpc.ServiceRegistrar, srv MessageServer) {
	// If the following call pancis, it indicates UnimplementedMessageServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Message_ServiceDesc, srv)
}

func _Message_ListSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ListSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ListSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ListSession(ctx, req.(*ListSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).SendMessage(ctx, req.(*SendMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_AckMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).AckMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_AckMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).AckMessage(ctx, req.(*AckMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_DeleteUserSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).DeleteUserSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_DeleteUserSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).DeleteUserSession(ctx, req.(*DeleteUserSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ListUnReadMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnReadMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ListUnReadMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ListUnReadMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ListUnReadMessage(ctx, req.(*ListUnReadMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).CreateGroup(ctx, req.(*CreateGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ListGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ListGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ListGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ListGroup(ctx, req.(*ListGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_DismissGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DismissGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).DismissGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_DismissGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).DismissGroup(ctx, req.(*DismissGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_InviteMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).InviteMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_InviteMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).InviteMember(ctx, req.(*InviteMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_MoveOutMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveOutMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).MoveOutMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_MoveOutMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).MoveOutMember(ctx, req.(*MoveOutMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ApplyInGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyInGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ApplyInGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ApplyInGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ApplyInGroup(ctx, req.(*ApplyInGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_HandleGroupApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleGroupApplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).HandleGroupApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_HandleGroupApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).HandleGroupApply(ctx, req.(*HandleGroupApplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ExitGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExitGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ExitGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ExitGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ExitGroup(ctx, req.(*ExitGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_UpdateGroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).UpdateGroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_UpdateGroupInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).UpdateGroupInfo(ctx, req.(*UpdateGroupInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ListGroupMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ListGroupMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ListGroupMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ListGroupMember(ctx, req.(*ListGroupMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_SearchGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).SearchGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_SearchGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).SearchGroup(ctx, req.(*SearchGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_ListGroupApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupApplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).ListGroupApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_ListGroupApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).ListGroupApply(ctx, req.(*ListGroupApplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Message_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Message_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServer).CreateSession(ctx, req.(*CreateSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Message_ServiceDesc is the grpc.ServiceDesc for Message service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Message_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "message.Message",
	HandlerType: (*MessageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSession",
			Handler:    _Message_ListSession_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _Message_SendMessage_Handler,
		},
		{
			MethodName: "AckMessage",
			Handler:    _Message_AckMessage_Handler,
		},
		{
			MethodName: "DeleteUserSession",
			Handler:    _Message_DeleteUserSession_Handler,
		},
		{
			MethodName: "ListUnReadMessage",
			Handler:    _Message_ListUnReadMessage_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _Message_CreateGroup_Handler,
		},
		{
			MethodName: "ListGroup",
			Handler:    _Message_ListGroup_Handler,
		},
		{
			MethodName: "DismissGroup",
			Handler:    _Message_DismissGroup_Handler,
		},
		{
			MethodName: "InviteMember",
			Handler:    _Message_InviteMember_Handler,
		},
		{
			MethodName: "MoveOutMember",
			Handler:    _Message_MoveOutMember_Handler,
		},
		{
			MethodName: "ApplyInGroup",
			Handler:    _Message_ApplyInGroup_Handler,
		},
		{
			MethodName: "HandleGroupApply",
			Handler:    _Message_HandleGroupApply_Handler,
		},
		{
			MethodName: "ExitGroup",
			Handler:    _Message_ExitGroup_Handler,
		},
		{
			MethodName: "UpdateGroupInfo",
			Handler:    _Message_UpdateGroupInfo_Handler,
		},
		{
			MethodName: "ListGroupMember",
			Handler:    _Message_ListGroupMember_Handler,
		},
		{
			MethodName: "SearchGroup",
			Handler:    _Message_SearchGroup_Handler,
		},
		{
			MethodName: "ListGroupApply",
			Handler:    _Message_ListGroupApply_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _Message_CreateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "message.proto",
}
